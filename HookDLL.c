/* An in-work Windows 10 Hijacker DLL that hijacks a thread in a running process by overwriting one of the instructions in its execution path (right before the ret statement)
by a JMP instruction. Once the thread has executed the Jump it is redirected to a 'malicious' function. Once the Malicious code is executed,
the original Opcode is restored so that the main thread can retain its original codeflow. Once the main thread
passes the now restored Original instruction the JMP instruction is again overwritten so that in case the main thread passes by the same address again
it will again be hijacked. This process continues on a loop to PERSISTENTLY Redirect the Main thread to our malicious function everytime it passes through
ReadProcessMemory
The 'Malicious' code in this function is simply to write the lpBaseAddress that was passed to ReadProcessMemory by the Main thread to a file E:\ReadProcCount.txt.
*/

#include "pch.h"
#include<Windows.h>
#include<strsafe.h>
#include<stdio.h>
#include<stdlib.h>

DWORD ReadProcJmpAddr, Kernel32ReleaseMutex, KernelBaseReleaseMutex, NtdllReleaseMutant;
BOOL DLLThreadSem = TRUE, GotMainThreadID = FALSE;
USHORT count = 1;
char file[25] = "E:\\ReadProcCount.txt";  //File to write the lpBaseAddress passed to ReadProcessMemory Calls in
char OrigOpCode[] = "\xB8\x01\x00\x00\x00\x8B"; //original mov eax,1 instruction that is overwritten with a JMP by the hijacker thread
HANDLE hMutex, hMutex1;
DWORD m_threadid, mainThreadID, i_threadid;


void _cdecl ReadProcMemTramp(DWORD lpBaseAddress)   // The trampoline function, The meat of the hijacked code.\n
{   												 // here it prints lpBaseAddress passed to ReadProcessMemory
    
    FILE* fPtr;
    fPtr = fopen(file, "a");
    fprintf(fPtr, "lpBaseAddress on count %d is: %08x", count, lpBaseAddress);
    fputs("\n", fPtr);
    fclose(fPtr);
    count++;

    memcpy((void*)ReadProcJmpAddr, (void*)OrigOpCode, 6);   // Replaces the JMP instruction with the original Opcode so that main thread can retain its original codeflow

    mainThreadID = GetCurrentThreadId();                     //Passes Main Thread identifier to Hijacker thread, Hijacker thread sets priority of main\n        
    GotMainThreadID = TRUE;                                  //thread to be lowest so that it doesn't miss any ReadProcessMemory calls by the main thread
}

_declspec(naked) _declspec(dllexport) void ReadProcMemHook()
{
    _asm {
        pushad                         //pushes all the registers on stack to save them for when we return to original Code Flow
        push 0xFFFFFFFF
        mov ebx, hMutex
        push ebx
        call WaitForSingleObject      // Acquires ownership of hMutex Object to stop overwrite of Jump Instruction by the Hijacker Thread
        mov ebx, [ebp + 0xC]          //pushes Read Address passed to ReadProcessMemory call
        push ebx
        call ReadProcMemTramp         //Calls the trampoline function where we put the meat of our 'malicious' code
        pop ebx
        mov ebx, hMutex
        push ebx
        call ReleaseMutex             //Releases hMutex to pass ownership to allow the Hijacker Thread to overwrite the Jump Instruction
        popad                         //We have to make sure while the Main thread is executing these addresses the Hijacker thread doesn't\n
        jmp[ReadProcJmpAddr]         //overwrite the Instruction (now replaced with original mov eax,1 instruction) otherwise an infinite loop will occur.\n
    }                                 //We do this by checking the EIP value of the main thread in the hijacker thread with the if block\n 
}                                     //before overwriting the Jump Instruction

DWORD HookJump = (DWORD)ReadProcMemHook;

void persistentRedirection()
{
    hMutex = CreateMutex(NULL, FALSE, NULL);    // Creates a Mutex to synchronize main thread and hijacker thread
    BOOL PrioritySet = FALSE;
    DWORD mainThID;
    HANDLE hmainTh = NULL;
    CONTEXT ContextmainTh;
    DWORD flOldProtect, ThID;
    BOOL stat;
    
    ReadProcJmpAddr = (DWORD)GetProcAddress(GetModuleHandleA("kernelbase.dll"), "ReadProcessMemory") + 0x2b;
    Kernel32ReleaseMutex = (DWORD)GetProcAddress(GetModuleHandleA("kernel32.dll"), "ReleaseMutex");
    KernelBaseReleaseMutex = (DWORD)GetProcAddress(GetModuleHandleA("kernelbase.dll"), "ReleaseMutex");
    NtdllReleaseMutant = (DWORD)GetProcAddress(GetModuleHandleA("ntdll.dll"), "ZwReleaseMutant");

    stat = VirtualProtect((LPVOID)ReadProcJmpAddr, 6, PAGE_EXECUTE_READWRITE, &flOldProtect);

    while (TRUE)
    {

        WaitForSingleObject(hMutex, INFINITE);     //The Hijacker thread obtains ownership of the Mutex so that it can safely overwrite the\n
                                                   //mov,eax 1 instruction with the JMP Instruction

        if (GotMainThreadID == FALSE)               //Hijacker Thread still hasn't received a handle to the Main Thread passed to it from trampoline function
        {

            *(char*)ReadProcJmpAddr = '\xFF';
            *(char*)(ReadProcJmpAddr + 1) = '\x25';
            *(DWORD*)(ReadProcJmpAddr + 2) = (DWORD)&HookJump;       //mov eax,1 Instruction overwritten by JMP


        }

        else                                      //Hijacker Thread has received handle to the Main Thread            
        {

            if (hmainTh == NULL)
            {
                hmainTh = OpenThread(THREAD_ALL_ACCESS, FALSE, mainThreadID);
            }

            if (PrioritySet == FALSE)
            {
                SetThreadPriority(hmainTh, THREAD_PRIORITY_LOWEST); //Main Thread priority set to lowest so that Hijacker Thread doesn't miss any ReadProcessMemory call
                PrioritySet = TRUE;
            }

            GetThreadContext(hmainTh, &ContextmainTh); //Main Thread EIP is peeked into to stop the Hijacker Thread from overwriting the original (mov eax,1) instruction again\n
                                                       //with the JMP Instruction when main thread has released the mutex but still hasn't reached the (mov eax,1) instruction
            DWORD Eip = ContextmainTh.Eip;

            if (!((Eip > ((DWORD)ReadProcMemHook + 0x12)) && (Eip < ((DWORD)ReadProcMemHook + 0x1E))) && (Eip != ((DWORD)ReadProcMemHook + 0x12)) && (Eip != ((DWORD)ReadProcMemHook + 0x1E)) && //Unsynched ReadProcMemHook Instructions after ReleaseMutex Call
                !((Eip > Kernel32ReleaseMutex) && (Eip < Kernel32ReleaseMutex + 5)) && (Eip != Kernel32ReleaseMutex) && (Eip != Kernel32ReleaseMutex + 5) &&    //Unsynched ReleaseMutex function in Kernel32, 0x5 is the total function size                             
                !((Eip > KernelBaseReleaseMutex) && (Eip < KernelBaseReleaseMutex + 0x1E)) && (Eip != KernelBaseReleaseMutex) && (Eip != KernelBaseReleaseMutex + 0x1E) &&  //Unsynched ReleaseMutex Function in KernelBase, 0x1e is the total function size
                !((Eip > NtdllReleaseMutant) && (Eip < NtdllReleaseMutant + 0xc)) && (Eip != NtdllReleaseMutant) && (Eip != NtdllReleaseMutant + 0xc) && //Unsynched ZwReleaseMutant function in NtDLL, 0xc is the total function size
                !((Eip > ReadProcJmpAddr) && (Eip < ReadProcJmpAddr + 0x4)) && (Eip != ReadProcJmpAddr) && (Eip != ReadProcJmpAddr + 0x4)     //Unsynched Jump Hook instruction in ReadProcessMemory, 0x4 is the instruction size
                )

            {
                *(char*)ReadProcJmpAddr = '\xFF';
                *(char*)(ReadProcJmpAddr + 1) = '\x25';
                *(DWORD*)(ReadProcJmpAddr + 2) = (DWORD)&HookJump;     //mov eax,1 Instruction overwritten by JMP

            }
        }
        ReleaseMutex(hMutex);
    }
}

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
)
{
    //DWORD flOldProtect, ThID;
    //BOOL stat;
    HANDLE hThread, hiThread;

    
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:

        hThread = CreateThread(NULL, NULL, (LPTHREAD_START_ROUTINE)persistentRedirection, NULL, NULL, &m_threadid); //Hijacker Thread is created
        SetThreadPriority(hThread, THREAD_PRIORITY_HIGHEST);

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

